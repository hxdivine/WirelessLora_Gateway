#include "systick.h"#include "stdio.h"#include "lora.h"#include "dealDat.h"#include "config.h"#include "hardware.h"#include "pub.h"#include "adc.h"#include "GSM234G.h"#include "tapdev.h"#include "iwdg.h"#include "loraDealDat.h"#include "sx127x_Drive.h"//比较时间#define ABSVAL_TIM(m1,m2)		(m1 < m2 ? m1 + 60 - m2:m1 - m2)#define CHECK_TIM(m1,m2)		(m1 > 30 ? m2 + 1:m2)//终端设备寄存器值 每个设备有7个数据u16 DevRegVal[MAXREG];//报警状态u8 DevAlarm[DEVICE_MAX] = {0};//接收缓存区 bufu8 loraRecBuf[LORA_BUF_MAX];//发送缓存区 bufu8 loraSendBuf[sizeof(LORA_PACKHEAD) + LORA_BUF_MAX + 1];//下发设置成功或者失败u8 DownloadId = 0;//临时存放刚开机设备TERMINNAL_INFO tempDev[DEVICE_MAX / 2] = {0};//设备上线数量u8 devPtr = 0;/*	获取已存在上线设备的数组下标*/u8 GetTempDevPtr(u8 *uId,u8 type){	u8 ptr = 0;	for(u8 i = 0,j = 0; i < 25; i++)	{		if(tempDev[i].avaliable == 1 && tempDev[i].type == type)		{			for(j = 0; j < 6; j++)			{				if(tempDev[i].uId[i] != uId[i])				{					break;				}			}			if(j < 6)			{				continue;			}			else			{				ptr = i + 1;				break;			}		}	}	return ptr;}/*	改变TempDev 存储的设备ID*/void ChangeTempDevID(u8 *uId,u8 type,u8 Id){	u8 ptr = GetTempDevPtr(uId,type);	if(ptr > 0)	{		tempDev[ptr - 1].Id = Id;		tempDev[ptr - 1].isNode = 1;	}}/*	设备已超出配置时间 进行删除*/void NewDevOffline(void){	static u8 sec = 0;	if(devPtr > 0 && ABSVAL_TIM(calendar.sec,sec) > 10)	{//每10s 扫描一次		sec = calendar.sec;		for(u8 i = 0,j = 0,k = devPtr; i < 25 && j < k; i++)		{			if(tempDev[i].avaliable == 1)			{//可配置时间减去20s				tempDev[i].onlineTim = tempDev[i].onlineTim > 10 ? tempDev[i].onlineTim - 10 : 0;				if(tempDev[i].onlineTim < 10)				{					tempDev[i].avaliable = 0;					tempDev[i].uId[0] = 0xFF;					devPtr--;								}				j++;			}		}	}}/*	检测是否已经存在的设备*/u8 CheckTempDev(u8 *uId,u8 type,u8 *ptr){	*ptr = GetTempDevPtr(uId,type);	if(*ptr == 0)	{		u8 i;		for(i = 0; i < 25; i++)		{			if(tempDev[i].avaliable != 1)			{				break;			}		}		return i + 1;	}	return 0;}/*	存储刚开机终端设备	需考虑 终端ID　终端UID是否一致*/u8 SaveTempDev(u8 *uId,u8 id,u8 type){	u8 tempPtr = 0;	u8 ptr = CheckTempDev(uId,type,&tempPtr);	if(ptr)	{		tempPtr = ptr;		tempDev[ptr - 1].avaliable = 1;		tempDev[ptr - 1].Id = id;		tempDev[ptr - 1].type = type;		for(u8 i = 0; i < 6; i++)		{			tempDev[ptr - 1].uId[i] = uId[i];		}		//剩余配置时间 = 5分钟 - 已在线时间		tempDev[ptr - 1].onlineTim = 300 - uId[6] * 60 > 10? 290 - uId[6] * 60:0;		if(type == DEV_WT100)		{//透传设备			tempDev[ptr - 1].baud = uId[7];			tempDev[ptr - 1].dataLen = uId[8];			tempDev[ptr - 1].stopLen = uId[9];			tempDev[ptr - 1].verifyType = uId[10];		}		tempDev[ptr - 1].isNode = 0;				devPtr = devPtr > (DEVICE_MAX / 2) ? DEVICE_MAX / 2 : devPtr + 1;	}	else	{//更新时间  防止时间不准确		tempDev[tempPtr - 1].onlineTim = 300 - uId[6] * 60 - 20;	}	return tempPtr == 0 ? 26:tempPtr-1;}/*	保存预警记录	mode 1 历史记录 0预警记录*/void SaveToHistory(u8 Index,u8 type,u8 mode){	if(mode)	{	//	SetHistory(Index,type,historyPtr);		SaveHistory(Index,type,1);	}	else	{	//	SetHistory(Index,type,alarmPtr);		SaveHistory(Index,type,0);	}}/*	判断是否为终端ID*/u8 isDevChipId(u8 *InBuf,u8 Index){	u8 i;	for(i = 0; i < 6; i++)	{//主机已删除设备		if(DevInfo[Index].uniId[i] != InBuf[i])		{			break;		}	}	if(i < 6)	{		return 0;	}		return 1;}/*	判断是不是本机ID*/u8 isChipId(u8 *InBuf){	u8 i;	for(i = 0; i < 3; i++)	{		if(ChipId[i] != (InBuf[i * 2] << 4 | InBuf[i * 2 + 1] & 0x0F))		{//不是本机ID			break;		}	}	if(i < 3)	{		return 0;	}	return 1;}/*	判断设备上线下线情况*/static void JudgeDevOnline(u8 *devRecTim){	static u8 TempTimCnt = 0;	if(timFlag)	{//timFlag作用 时间设置了 据下一次设备查询设置为 1 个周期		if(calendar.min < SysInfo.TerminalRepCycle)		{			TempTimCnt = calendar.min + 60 - SysInfo.TerminalRepCycle;		}		else		{			TempTimCnt = calendar.min - SysInfo.TerminalRepCycle;		}		timFlag = 0;	}	//3个上报周期查询一次  一个周期最小2min 	if(ABSVAL_TIM( CHECK_TIM(calendar.sec,calendar.min),TempTimCnt) > SysInfo.TerminalRepCycle * 3)	{		TempTimCnt = CHECK_TIM(calendar.sec,calendar.min);		for(u8 i = 0; i < DEVICE_MAX; i++)		{ //2个周期没有接收到 数据  设置为 离线状态			if(DevInfo[i].isExist == 1)			{				if(ABSVAL_TIM(TempTimCnt,devRecTim[i]) > SysInfo.TerminalRepCycle * 2 - 1)				{					DevInfo[i].isExist = 0;				}			}			devRecTim[i] = 0;		}	}}/*	设置终端设备寄存器值*/void SetDevRegVal(u8 Index,u8 *InBuf,u8 *AlarmFlag,u8 type){	u8 num = 7;	*AlarmFlag = 0;	switch(type)	{		case DEV_WT102:		case DEV_WT103:		case DEV_WT104:			num = 2;		break;				case DEV_WT105:		case DEV_WT106:		case DEV_WT108:		case DEV_WT109:			num = 1;		break;		case DEV_WT101:			num = 4;		break;		case DEV_WT111:			num = 6;		break;		default:			break;	}		//温度 湿度 光照度 CO2 CTOV  土壤温度 土壤湿度 Bat	//WT108 WT109 WT102只上报一部分数据 字节数未满以255填充	for(u8 i = 0; i < num; i++)	{		DevRegVal[Index * 7 + i] = (InBuf[i * 2] << 8) | InBuf[i * 2 + 1];				if(DevRegVal[Index * 7 + i] & 0x8000)		{//负数   			if(DevRegVal[Index * 7 + i] > DevInfo[Index].LowLim[i])			{//小于低限预警值  这里只判断 小于低限值 不判断高限值 高限一定为正				*AlarmFlag = 1;			}		}		else		{//DevRegVal[Index * 7 + i] 正数			if(DevRegVal[Index * 7 + i] > DevInfo[Index].HighLim[i])			{//大于高限预警值				*AlarmFlag = 1;			}			else if(DevRegVal[Index * 7 + i] < DevInfo[Index].LowLim[i])			{//小于低限预警值				if(DevInfo[Index].LowLim[i] & 0x8000 == 0x0)				{//只有当下限是正值时 预警成立					*AlarmFlag = 1;				}			}		}	}	//电池电压	if(type >= DEV_WT103 && type <= DEV_WT104)	{		DevRegVal[Index * 7 + 2] = (InBuf[4] << 8) | InBuf[5];	}	else if(type >= DEV_WT105 && type <= DEV_WT106)	{		DevRegVal[Index * 7 + 1] = (InBuf[2] << 8) | InBuf[3];	}	DevAlarm[DevInfo[Index].deviceId - 1] = 0;	if(type == DEV_WT102 || type == DEV_WT101)	{//DEV_WT102 没有上下限		*AlarmFlag = 0;	}	if(DevAlarm[DevInfo[Index].deviceId - 1] == 1 && !(*AlarmFlag))	{		DevAlarm[DevInfo[Index].deviceId - 1] = 2;	}	else	{		DevAlarm[DevInfo[Index].deviceId - 1] = *AlarmFlag;	}}/*	LoRa数据接收检测*/u8 LoraPro(void){	static u8 devRecTim[DEVICE_MAX];			//接收次数	LORA_PACKHEAD *loraPackHead = (LORA_PACKHEAD *)&loraRecBuf;	u8 recLen = LoraDatPro();			//检测数据是否到达	u8 Index = 0;	u8 sum = 0;	u8 tempDevIndex = 0;	//外部电源存在	JudgeDevOnline(devRecTim);	WatchDogFeed();	if(recLen > 0)	{//有数据接收到		//用于判断接收的传感器数据是否高于或低于预警值		u8 AlarmFlag = 0;		//异或  最后与校验 异或 相同为0		for(u8 i = 0; i < recLen; i++)		{//校验			sum ^= loraRecBuf[i];		}		if(sum == 0 && loraPackHead->tar == 0)		{//0就是 本机地址			if(DB_Flag == 1)			{				printf("LoraRecID:%d,Type:%d\r\n",loraPackHead->src,loraPackHead->srcType);			}			//FB配置指令			if(loraPackHead->PackSeq == 0xFB)			{				tempDevIndex = SaveTempDev(&loraRecBuf[sizeof(LORA_PACKHEAD) + 6],loraPackHead->src,loraPackHead->srcType);					//下发心跳				if(loraPackHead->srcType != DEV_WT100)				{					SendLoraData(loraPackHead->src,0xFD,&loraRecBuf[sizeof(LORA_PACKHEAD) + 6],6);				}				else				{						if(isChipId(&loraRecBuf[sizeof(LORA_PACKHEAD)]) && tempDevIndex != 26)					{						tempDev[tempDevIndex].isNode = 1;					}					SendLoraData(loraPackHead->src + DEVICE_MAX,0xFC,&loraRecBuf[sizeof(LORA_PACKHEAD) + 6],6);					return 1;				}			}			else if(loraPackHead->PackSeq == 255)			{//主机下发设置 回应				DownloadId = loraPackHead->src;				overAllData_Fram.recLen = 0;			}						if(!isChipId(&loraRecBuf[sizeof(LORA_PACKHEAD)]))			{				return 1;			}			if(loraPackHead->srcType != DEV_WT100)			{//是来自终端设备上报数据				Index = loraPackHead->src - 1;				if(!isDevChipId(&loraRecBuf[sizeof(LORA_PACKHEAD) + 6],Index))				{					return 1;				}					if(loraPackHead->PackSeq == 0xFB && tempDevIndex != 26)				{					tempDev[tempDevIndex].isNode = 1;				}				//更新设备在线状态				DevInfo[Index].isExist = 1;				if(loraPackHead->RepCycle != 0 && loraPackHead->RepCycle  != 255)				{	//当前设备接收数据次数					devRecTim[Index] = calendar.min;					//终端数据上报					//WT107 108 109 WT102 WT104					if(recLen >= sizeof(LORA_PACKHEAD) + 26)					{						SetDevRegVal(Index,&loraRecBuf[sizeof(LORA_PACKHEAD) + 13],&AlarmFlag,loraPackHead->srcType);					}				}				if(loraPackHead->PackSeq == 0x0B)				{					//下发心跳					SendLoraData(loraPackHead->src,0xFD,&loraRecBuf[sizeof(LORA_PACKHEAD) + 6],6);				}			}			else			{					//透传来的 数据				if(loraPackHead->PackSeq == 1)				{//GPRS					SendGprsDat(&loraRecBuf[sizeof(LORA_PACKHEAD) + 6],loraPackHead->len - sizeof(LORA_PACKHEAD) - 7);				}				else if(loraPackHead->PackSeq == 2)				{//rj45 server					UipServer2Client(&loraRecBuf[sizeof(LORA_PACKHEAD) + 6],(u32)(loraPackHead->len - sizeof(LORA_PACKHEAD) - 7));				}				else if(loraPackHead->PackSeq == 3)				{//client					UipClient2Server(&loraRecBuf[sizeof(LORA_PACKHEAD) + 6],loraPackHead->len - sizeof(LORA_PACKHEAD) - 7);				}			}		}				if(AlarmFlag == 1)		{//产生预警			SaveToHistory(loraPackHead->src - 1,loraPackHead->srcType,0);		}		else		{			SaveToHistory(loraPackHead->src - 1,loraPackHead->srcType,1);		}		return 1;	}	return 0;}/*	LoRa传感器数据发送	tar：目标  终端设备id	seq：命令	buf: 发送缓存区	len；数据长度*/void SendLoraPack(u8 tar,u8 seq,u8 *buf,u8 len){	u8 i;	u8 sum = 0;	u16 tempRepCnt = RepCnt;	LORA_PACKHEAD *loraPackHead = (LORA_PACKHEAD *)&loraSendBuf;	if(len > LORA_BUF_MAX)	{		return;	}	loraPackHead->len = sizeof(LORA_PACKHEAD) + len + 1 + 6;	loraPackHead->src = 0;		//源地址 本机	loraPackHead->srcType = 0xFE;	//类型	loraPackHead->tar = tar;	//目标地址	loraPackHead->PackSeq = seq;	loraPackHead->RepCycle = SysInfo.TerminalRepCycle;	loraPackHead->RepCntH = tempRepCnt >> 8;	loraPackHead->RepCntL = tempRepCnt & 0xFF;	loraPackHead->workFreq = tempWorkfreq;		loraSendBuf[sizeof(LORA_PACKHEAD)] = ChipId[0] >> 4;	loraSendBuf[sizeof(LORA_PACKHEAD) + 1] = ChipId[0] & 0x0F;	loraSendBuf[sizeof(LORA_PACKHEAD) + 2] = ChipId[1] >> 4;	loraSendBuf[sizeof(LORA_PACKHEAD) + 3] = ChipId[1] & 0x0F;	loraSendBuf[sizeof(LORA_PACKHEAD) + 4] = ChipId[2] >> 4;	loraSendBuf[sizeof(LORA_PACKHEAD) + 5] = ChipId[2] & 0x0F;	RFLED_ENABLE;	if(buf != NULL)	{		for(i = 0; i < len; i++)		{			loraSendBuf[sizeof(LORA_PACKHEAD) + i + 6] = buf[i];		}	}		for(i = 0; i < sizeof(LORA_PACKHEAD) + len + 6; i++)	{		sum ^= loraSendBuf[i];	}	loraSendBuf[i] = sum;	SendLoraDatPack(loraSendBuf,sizeof(LORA_PACKHEAD) + len + 1 + 6);}/*	lora传感器发送数据*/u8 SendLoraData(u8 tar,u8 seq,u8 *buf,u8 len){	if(seq != 0xFD)	{//是设置命令 先查找空闲		JudgeDevSendTim();	}/*	if(SX127X_SetFreq(0))	{		delayMs(70);		WatchDogFeed();		SendLoraPack(tar,seq,buf,len);		delayMs(118);		SX127X_SetFreq(SysInfo.Workfreq);		return 1;	}	*/	WatchDogFeed();	SendLoraPack(tar,seq,buf,len);	delayMs(135);	return 1;}/*	发送数据到指定ID设备 WT107 WT108 WT109 WT102	id; 设备Id	mode: 1为DO终端开关设置	option: 0关 1开 */u8 DownLoad2TerminalWT2(u8 id,u8 mode,u8 option){	u8 seq = 0xFF;	//用于检测数据是否到达设备	DownloadId = 0;		if(!(id > 0 && id < DEVICE_MAX))	{//id大于最大设备数		return 0;	}	id -= 1;	if(DevInfo[id].deviceId > DEVICE_MAX || DevInfo[id].deviceId == 0)	{//不存在该设备ID 		return 0;	}		overAllData_Fram.recLen = 0;	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].uniId[0];	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].uniId[1];	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].uniId[2];	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].uniId[3];	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].uniId[4];	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].uniId[5];	if(mode == 2)	{		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[0] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[0] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[0] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[0] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[1] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[1] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[1] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[1] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[2] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[2] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[2] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[2] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[3] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[3] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[3] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[3] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[4] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[4] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[4] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[4] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[5] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[5] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[5] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[5] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[6] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].HighLim[6] & 0xFF;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[6] >> 8;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = DevInfo[id].LowLim[6] & 0xFF;	}	else if(mode == 1)	{//DO 写入		if(DevInfo[id].Type != DEV_WT102)		{			return 0;		}		seq = 0xF1;		overAllData_Fram.recBuf[overAllData_Fram.recLen++] = option;	}	WatchDogFeed();	//前一ID 指定ID 后一255为设置	if(SendLoraData(id+1,seq,overAllData_Fram.recBuf,overAllData_Fram.recLen))	{		for(u8 i = 0; i < 50; i++)		{			//等待数据包发送过来			LoraPro();			delayMs(20);			if(DownloadId)			{//下发设置成功				break;			}		}	}	WatchDogFeed();	//下发设置失败	if(DownloadId == 0)	{		return 0;	}	return 1;}/*	发送数据至WT100	Inbuf：包含波特率 数据位 停止位 校验位*/u8 DownLoad2TerminalWT1(u8 id,u8 *InBuf){	//用于检测数据是否到达设备	DownloadId = 0;	overAllData_Fram.recLen = 0;	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = InBuf[0];	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = InBuf[1];	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = InBuf[2];	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = InBuf[3];	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = InBuf[4];	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = InBuf[5];	//波特率 1(2400) 2(4800) 3(9600) ... 9(115200)	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = id;	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = InBuf[7] - '0';	//波特率	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = InBuf[9] - '0';	//数据位	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = InBuf[13] - '0';	//停止位	overAllData_Fram.recBuf[overAllData_Fram.recLen++] = InBuf[11] - '0';	//校验位	WatchDogFeed();	if(SendLoraData(id + DEVICE_MAX,255,overAllData_Fram.recBuf,overAllData_Fram.recLen))	{		//前一255广播  后一255为设置		for(u8 i = 0; i < 50; i++)		{			//等待数据包发送过来			LoraPro();			delayMs(20);			if(DownloadId)			{//下发设置成功				break;			}		}	}	WatchDogFeed();	//下发设置失败	if(DownloadId == 0)	{		return 0;	}	return 1;}/*	更改lora传感器工作频段*/void SetWorkFreq(void){	SX127X_SetFreq(SysInfo.Workfreq);}