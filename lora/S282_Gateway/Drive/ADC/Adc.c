#include "Adc.h"#include "gd32e10x.h"#include "iwdg.h"#include "systick.h"#include "pub.h"#include "stdio.h"u16 LocalBatVal;/*	ADC0 中断使能设置*/void ADC_EXTI_Init(void){	//清楚中断标志	adc_interrupt_flag_clear(ADC0,ADC_INT_EOC);	//开启中断	adc_interrupt_enable(ADC0,ADC_INT_EOC);	adc_calibration_enable(ADC0);	}/*	ADC0 初始化*/void InitAdc(void){	adc_deinit(ADC0);	//状态寄存器 置为0	ADC_STAT(ADC0) = 0;	//单次转换需要将ctl0 ctl1 置为0	ADC_CTL0(ADC0) = 0;	ADC_CTL1(ADC0) = 0;	rcu_periph_clock_enable(RCU_ADC0);	rcu_periph_clock_enable(RCU_AF);//	gpio_init(GPIOA,GPIO_MODE_AIN,GPIO_OSPEED_50MHZ,GPIO_PIN_12);	//配置ADC同步配置	adc_mode_config(ADC_MODE_FREE);	//多通道扫禁止	adc_special_function_config(ADC0,ADC_SCAN_MODE,DISABLE);	//连续进行禁止	adc_special_function_config(ADC0,ADC_CONTINUOUS_MODE,ENABLE);	//软件触发	adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_EXTTRIG_REGULAR_NONE);	//外部触发	adc_external_trigger_config(ADC0,ADC_REGULAR_CHANNEL,ENABLE);	//数据对齐方式 右对齐	adc_data_alignment_config(ADC0,ADC_DATAALIGN_RIGHT);	//规则通道组长度1	adc_channel_length_config(ADC0,ADC_REGULAR_CHANNEL,1);	//规则组配置	adc_regular_channel_config(ADC0,0,ADC_CHANNEL_0,ADC_SAMPLETIME_239POINT5);	adc_enable(ADC0);	delayMs(10);	//校准复位	adc_calibration_enable(ADC0);		adc_software_trigger_enable(ADC0,ADC_REGULAR_CHANNEL);	ADC_EXTI_Init();}void ADC0_1_IRQHandler(void){	static u8 Cnt = 0;	u16 batVal = 0;	if(adc_interrupt_flag_get(ADC0,ADC_INT_FLAG_EOC) != RESET)	{		Cnt++;		if(Cnt == 100)		{			Cnt = 0;			batVal = adc_regular_data_read(ADC0);			LocalBatVal = (batVal * 3300 * 4 / 3 / 4096);			//			printf("Bat:%d\r\n",batVal);		}		adc_interrupt_flag_clear(ADC0,ADC_INT_FLAG_EOC);	}}