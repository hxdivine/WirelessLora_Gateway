#include "stdlib.h"#include "stdio.h"#include "config.h"#include "spi_flash.h"#include "sysFlash.h"#include "hardware.h"__align(4) SYSINFO SysInfo;__align(4) USERINFO UserInfo;__align(4) HISTORY History;TERMINALINFO_WT2 DevInfo[DEVICE_MAX];/*	系统参数不采用外部flash	原因在读取外部flash时，因电源接触问题 会导致读取数据丢失*/#define PAGE_SIZE		0x400U//主机设备信息 一页写不完需要两页 1088bytes#define SYS_ADR			((uint32_t)(0x08000000 +  PAGE_SIZE * 125))	//基本用户配置信息地址  24bytes#define DEV_ADR			((uint32_t)(0x08000000 +  PAGE_SIZE * 127))	void EraseChipOrSector(u32 addr,u8 mode){	if(mode)	{		W25Q_Erase_Sector(addr);	}	else	{		W25Q_Erase_Chip();	}}/*	从内存读取基本配置信息*/void ReadConfig(u8 mode,u8 *InBuf,u8 ptr){	switch(mode)	{		case SYSINFO_MODE:					//主机s282			Fmc_ReadToFlash(SYS_ADR,(uint32_t*)InBuf,sizeof(SysInfo)/4);			break;		case TERMINALWT2_MODE:			//终端			if(ptr >= DEVICE_MAX)			{				return;			}			if(ptr == 1)				W25Q_Read(InBuf,DEV_ADDR_1(0),sizeof(TERMINALINFO_WT2)*25);			else				W25Q_Read(InBuf,DEV_ADDR(0),sizeof(TERMINALINFO_WT2)*25);			break;			case USERINFO_MODE:					//用户配置			Fmc_ReadToFlash(DEV_ADR,(uint32_t*)InBuf,sizeof(USERINFO)/4);			break;		default:			break;	}}/*	将本机基本配置信息写入到内存中	50台设备分两部分存储	如果一个一个设备的存储 会出现隔几天后 能写无法读的问题*/void WriteConfig(u8 mode,u8 *InBuf,u8 ptr){	switch(mode)	{		case SYSINFO_MODE:					//主机s282			Fmc_WriteToFlash(SYS_ADR,InBuf,sizeof(SYSINFO));			break;		case TERMINALWT2_MODE:			//终端			if(ptr > DEVICE_MAX)			{				return;			}			if(ptr == 1)				W25Q_Write(InBuf,DEV_ADDR_1(0),sizeof(TERMINALINFO_WT2)*25);			else				W25Q_Write(InBuf,DEV_ADDR(0),sizeof(TERMINALINFO_WT2)*25);			break;		case USERINFO_MODE:					//用户配置			Fmc_WriteToFlash(DEV_ADR,InBuf,sizeof(USERINFO));			break;		default:			break;	}}void ReadHistory(u8 mode,u8 *InBuf,u16 ptr){	u16 Shift = 0;	u32 AddrBase = 0;	u8 *tmpHistory = malloc(4096);	if(tmpHistory == NULL)	{		printf("内存不足");		return;	}	switch(mode)	{		case HISTORYCORD_MODE:			AddrBase = HISRECORD_ADDR(ptr) & 0xFFFFF000;			Shift = HISRECORD_ADDR(ptr) & 0xFFF;		break;		case HISTORY_REPORTCORD_MODE:				AddrBase = HISTORY_REPDATCORD_ADDR(ptr) & 0xFFFFF000;			Shift = HISTORY_REPDATCORD_ADDR(ptr) & 0xFFF;		break;		case ALARM_MODE:			AddrBase = ALARM_ADDR(ptr) & 0xFFFFF000;			Shift = ALARM_ADDR(ptr) & 0xFFF;			break;	}	W25Q_Read(tmpHistory,AddrBase,4096);	for(u8 i = 0; i < 32; i++)	{		InBuf[i] = tmpHistory[Shift + i];	}	free(tmpHistory);}//u8 tmpHistory[4096];void WriteHistory(u8 mode,u8 Index,u8 type,u16 ptr){	u16 Shift = 0;	u32 AddrBase = 0;	u8 *tmpHistory = malloc(4096);	if(tmpHistory == NULL)	{		printf("内存不足");		return;	}	switch(mode)	{		case HISTORYCORD_MODE:			AddrBase = HISRECORD_ADDR(ptr) & 0xFFFFF000;			Shift = HISRECORD_ADDR(ptr) & 0xFFF;		break;		case HISTORY_REPORTCORD_MODE:				AddrBase = HISTORY_REPDATCORD_ADDR(ptr) & 0xFFFFF000;			Shift = HISTORY_REPDATCORD_ADDR(ptr) & 0xFFF;		break;		case ALARM_MODE:			AddrBase = ALARM_ADDR(ptr) & 0xFFFFF000;			Shift = ALARM_ADDR(ptr) & 0xFFF;			break;	}		W25Q_Read(tmpHistory,AddrBase,4096);	HISTORY *his = (HISTORY*)&tmpHistory[Shift];	SetHistory(his,Index,type,ptr);	W25Q_Write(tmpHistory,AddrBase,4096);	free(tmpHistory);}