#include "uip_appcall.h"#include "def.h"#include "uip.h"#include <string.h>#include <stdio.h>	   #include "EthNet.h"#include "tapdev.h"u16 g_RecEthLen;u8 tcp_client_sendbuf[500];  	//发送数据缓存	  __align(2)  u8 tcp_client_Recbuf[500];//接收数据缓存u8 tcp_client_sta;				//客户端状态/*	复制函数*/u16 u8cpy(u8 *dest, u8 *src, u16 max){	u16 i=0;	u16 j=0;		for(i=0;i<max;i++)	{		dest[j++]=src[i];	}	return j;}//[7]:0,无连接;1,已经连接;//[6]:0,无数据;1,收到客户端数据//[5]:0,无数据;1,有数据需要发送/*	这是一个TCP 客户端应用回调函数。*/void tcp_client_appcall(void){		   	struct uip_appstate *s = (struct uip_appstate *)&uip_conn->appstate;	u8 i = 0;	if(uip_aborted())	{	//连接终止			uip_log("tcp_client uip_aborted!\r\n");		g_mconn[i].flag |= e_Tcp_aborted;	   	}	if(uip_timedout())	{//连接超时   		uip_log("tcp_client uip_timedout!\r\n");//打印log		g_mconn[i].flag |= e_Tcp_timedout;	}	if(uip_closed())	{//连接关闭	 		uip_log("uip_closed by server\r\n");//打印log		g_mconn[i].flag |= e_Tcp_closed;   	}	if(uip_connected())	{	//连接成功			uip_log("tcp_client connected!\r\n");//打印log//		sprintf((char*)tcp_client_sendbuf,"TEST\r\n");					s->textptr = tcp_client_sendbuf;			s->textlen = strlen((const char*)tcp_client_sendbuf);			uip_send(s->textptr, s->textlen);//发送TCP数据包			g_mconn[i].flag |= e_Tcp_connected;  	}	if(uip_acked())	{	//发送的数据成功送达 		g_mconn[i].flag |= e_Tcp_acked; 	}	//接收到一个新的TCP数据包 	if (uip_newdata() && uip_len)	{		if(g_RecEthLen == 0)		{			g_RecEthLen = uip_len;			u8cpy(&tcp_client_Recbuf[0], uip_appdata, uip_len);			}	     	}				if(uip_poll())	{	//当前连接空闲轮训		//uip_log("tcp_client uip_poll!\r\n");//打印log		if(g_mconn[i].flag & e_Tcp_poll)		{			s->textptr = &g_mconn[i].sbuf[2];			s->textlen = (g_mconn[i].sbuf[0]<<8)+g_mconn[i].sbuf[1];			g_mconn[i].flag &= ~e_Tcp_poll;//清除标记			uip_send(s->textptr, s->textlen);//发送TCP数据包			}	}		if(uip_rexmit())	{ //重发 		//uip_send(s->textptr, s->textlen);//发送TCP数据包		s->textptr = &g_mconn[i].sbuf[2];		s->textlen = (g_mconn[i].sbuf[0]<<8)+g_mconn[i].sbuf[1];		uip_send(s->textptr, s->textlen);//发送TCP数据包		}										   }/*	发送数据给服务端	s->textptr:发送的数据包缓冲区指针	s->textlen:数据包的大小（单位字节）*/void tcp_client_senddata(void){	struct uip_appstate *s = (struct uip_appstate *)&uip_conn->appstate;	//发送TCP数据包	 	if(s->textlen > 0)	{		uip_send(s->textptr, s->textlen);	}}