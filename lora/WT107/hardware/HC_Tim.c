#include "hardware.h"#include "HC_Tim.h"#include "bt.h"TIM_CLOCK timClock = {0,0};/*	定时器0初始化  用于定时配置时间	48000 * (1/48M) * 256 = 256ms) 实际不标准  23400达到250ms左右	1000ms / 256 * (48M) = Cnt*/void TimInit(void){	stc_bt_mode0_cfg_t stcBtBaseCfg;	DDL_ZERO_STRUCT(stcBtBaseCfg);	Sysctrl_SetPeripheralGate(SysctrlPeripheralBaseTim, TRUE);	//定时器模式初始化	stcBtBaseCfg.enWorkMode = BtWorkMode0;	stcBtBaseCfg.enCT = BtTimer;	stcBtBaseCfg.enPRS = BtPCLKDiv256;	stcBtBaseCfg.enCntMode = Bt16bitArrMode;	stcBtBaseCfg.bEnGate = FALSE;	stcBtBaseCfg.bEnTog = FALSE;	stcBtBaseCfg.enGateP = BtGatePositive;	Bt_Mode0_Init(TIM0,&stcBtBaseCfg);	//重装载数值  65536 - 48000	Bt_M0_ARRSet(TIM0,65536 - 23400);	//计数初值   65536 - 48000	Bt_M0_Cnt16Set(TIM0,65536 - 23400);	//清除中断标志	Bt_ClearIntFlag(TIM0,BtUevIrq);	//中断使能	Bt_Mode0_EnableIrq(TIM0); 	EnableNvic(TIM0_IRQn, IrqLevel0, TRUE);		Bt_M0_Run(TIM0);}/*	时间设置*/void TimSet(void){	timClock.sec += 1;	if(timClock.sec > 59)	{		timClock.sec = 0;		timClock.min += 1;		if(timClock.min > 60)		{			timClock.min = 0;		}	}}/*	中断服务函数*/void TIM0_IRQHandler(void){	static u8 msCnt = 0;	//250ms产生 误差+1ms	if(Bt_GetIntFlag(TIM0, BtUevIrq))	{		msCnt += 1;		if(msCnt >= 4)		{			msCnt = 0;			TimSet();		}		//清除中断标志+		Bt_ClearIntFlag(TIM0,BtUevIrq);	}}/*	获取系统设定秒数*/u8 GetSysSec(void){	return timClock.sec;}/**	获取系统设定分钟*/u8 GetSysMin(void){	return timClock.min;}